# Array vs Linked List

# 📌 Array

메모리 공간에 할당할 사이즈를 미리 정해놓고 사용하는 자료구조

### 특징

- 논리적 저장순서와 물리적 저장순서 일치
- 특정 자료형들이 메모리 공간 상 연속적으로 이루어짐
- immutable
- 인덱스로 원소 접근 가능. 인덱스 알고 있으면 시간 복잡도 O(1). → Random Access 가능
- 삭제, 삽입 시 해당 원소에 접근하여 작업 완료한 뒤, Shift 해줘야하므로 비용 발생 : O(n)
- 메모리 공간 활용에 제약이 있음.
- 검색 : O(1) / 삽입, 삭제 : O(n)
- 빠르게 데이터를 <pre>찾는</pre> 것이 가능

# 📌 Linked List

한 노드에 연결될 노드의 포인터 위치를 가리키는 방식

### 특징

- 논리적 저장순서와 물리적 저장순서 불일치 → 데이터 검색시 처음 노드부터 순회해야 함. O(n)
- 메모리 공간 상 각 노드들이 연속적으로 이루어져 있지 않고 흩어져 있음. (각각의 노드가 자신의 다음 노드의 위치를 알고 있는 형태)
- 각 노드들이 메모리 공간 상의 어디에 위치하는지는 각각의 노드들만 알고 있음. 사용자는 가장 첫 번째 노드의 위치만 앎.
- 원소 삭제, 삽입 시 해당 원소를 찾기 위해 O(n) 의 시간 복잡도 발생. 추가적으로, 작업을 완료하는 시간까지 O(n)의 시간이 걸림.
- 검색, 삭제, 삽입 모두 O(n)
- 빠르게 데이터를 삽입, 삭제하는 것이 가능
  - How? 전체를 돌지 않고, 이전값과 다음값이 가리켰던 주소값만을 수정하여 연결시켜주면 됨.

# 📌 Array VS Linked List

### 데이터 접근 속도

[Array]

- 인덱스 사용하여 빠르게 접근. O(1)
- Random Access

[Linked List[

- 처음부터 순차적으로 검색 O(N)
- Sequential Access

### 데이터 삽입 속도

[Array]

- 중간이나 맨 앞 삽입할 경우, 삽입하고자 하는 위치 이후의 데이터를 Shift 해야 하므로 추가 과정 및 시간 소요  : O(n)
- 데이터 많은 경우 비효율적
- 공간 꽉 찼을 경우, 새로운 메모리 공간 할당받아야 함.

[Linked List]

- 맨 앞, 뒤 삽입할 경우, O(1)
- 중간 삽입할 경우, 위치 검색{ O(n) } + 삽입 연산{ O(n) } 진행하므로, O(n)
- Array 보다 빠른 성능
- 공간 꽉 찼을 경우, 추가할 때마다 동적 메모리 공간 할당 가능

### 데이터 삭제 속도

[Array]

- 그 위치의 데이터를 삭제한 후, 전체적으로 앞으로 Shift : O(n)

[Linked List]

- 삭제할 원소 찾기 O(n) + 삭제 연산 O(n) : O(n)
- Array 보다 빠른 성능

### 메모리 성능

[Array]

- Array가 선언되자마자 compile time에 할당됨.
- 정적 메모리 할당

[Linked List]

- 새로운 node 가 추가될 때마다 runtime에 할당됨.
- 동적 메모리 할당

### 결론

- 삽입 삭제 빈번하게 일어난다? → Linked List 사용
- 데이터 접근이 빈번하게 일어난다? → Array 사용